# A0138411N
###### /java/seedu/ggist/commons/events/storage/ChangeSaveFileEvent.java
``` java
/**
 * An event indicating the save file location or the file name has been changed
 */
public class ChangeSaveFileEvent extends BaseEvent{

    public static String path;
    
    public ChangeSaveFileEvent(String path) {
        this.path = path;
    }
    
    @Override
    public String toString() {
        return "new save file path: " + path;
    }

}
```
###### /java/seedu/ggist/commons/events/ui/ChangeFileLocationEvent.java
``` java
/**
 * An event indicating the new save file location or save file name to be reflected in UI
 */
public class ChangeFileLocationEvent extends BaseEvent{

    public String path;
    public ChangeFileLocationEvent(String path) {
        this.path = path;
    }
    @Override
    public String toString() {
        return  this.getClass().getSimpleName();
    }
}
```
###### /java/seedu/ggist/logic/commands/AddCommand.java
``` java
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task\n"
            + "Parameters: TASK, [DATE] [TIME] [-PRIORITY]\n"
            + "Example: " + COMMAND_WORD
            + " examination period from friday 1pm to next friday 12pm -high";
    
    public static final String MESSAGE_SUCCESS = "New %1$s added: %2$s";
    public static final String MESSAGE_DUPLICATE_TASK = "duplicated tasks found";
      
    private final Task toAdd;
    private Task.TaskType taskType;

    /**
     * Adds an event task
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String taskName, String startDate, String startTime, String endDate, String endTime, String priority) throws IllegalValueException {      
        
        if (startTime.equals("")) {
            startTime = Messages.MESSAGE_NO_START_TIME_SET;
        }
               
        if (endTime.equals("")) {
            endTime = Messages.MESSAGE_NO_END_TIME_SET;
        }
        this.toAdd = new EventTask(
                new TaskName(taskName),
                new TaskDate(startDate),
                new TaskTime(startTime),
                new TaskDate(endDate),
                new TaskTime(endTime),
                new Priority(priority)
        );
        taskType = Task.TaskType.EVENT;
    }
    
    /**
     * Adds a deadline task
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String taskName, String date, String endTime, String priority) throws IllegalValueException {      
        
        if (endTime.equals("")) {
            endTime = Messages.MESSAGE_NO_END_TIME_SET;
        }
        
        this.toAdd = new DeadlineTask(
                new TaskName(taskName),
                new TaskDate(date),
                new TaskTime(endTime),
                new Priority(priority)
        );
        taskType = Task.TaskType.DEADLINE;
    }
    
    /**
     * Adds a floating task
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String taskName, String priority) throws IllegalValueException {      

        this.toAdd = new FloatingTask(
                new TaskName(taskName),
                new Priority(priority)
        );
        taskType = Task.TaskType.FLOATING;
    }
    
    public String getTaskType() {
        return taskType.toString();
    }
```
###### /java/seedu/ggist/logic/commands/Command.java
``` java
    /**
     * Raises an event to indicate a correct command
     */
    protected void indicateCorrectCommandExecuted() {
        EventsCenter.getInstance().post(new CorrectCommandExecutedEvent(this));
    }
}
```
###### /java/seedu/ggist/logic/commands/ListCommand.java
``` java
/**
 * Lists specified tasks in GGist to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": retreives preferred tasks listing in GGist.\n"
            + "Parameter: [all] , [done] , [low/med/high] or [DATE]\n"
            + "Empty paramter lists all undone tasks in GGist\n"
            + "Example: " + COMMAND_WORD + " done or " + COMMAND_WORD + " 13 Oct/monday/today";
    private final static String LIST_ARGS_VALIDATION = "(all)|(done)|(high)|(med)|(low)|(\\w{3}, \\d{2} \\w{3} \\d{2})"; 
    
    private String listing;
        
    public ListCommand(String argument) throws IllegalValueException {
        assert argument != null;
        listing = argument;
    }
    
    /**
     * Validates the listing argument
     * @param String argument
     * @return true if is valid list argument
     */
    public static boolean isValidListArgs(String test) {
        return test.matches(LIST_ARGS_VALIDATION);
    }
    
    /**
     * Updates filtered task list in Model Manager according to the listing
     * Post an event to indicate listing changed
     */
    @Override
    public CommandResult execute() {
        if (listing.equals("all")) {
            model.updateFilteredListToShowAll();
        } else if (listing.equals("done")) {
            model.updateFilteredListToShowAllDone();
        } else if (listing.equals(Priority.PriorityType.LOW.toString()) || listing.equals(Priority.PriorityType.MEDIUM.toString()) 
                   || listing.equals(Priority.PriorityType.HIGH.toString())) {
            model.updateFilteredListToPriority(listing);
        } else if (TaskDate.isValidDateFormat(listing)) {
            model.updateFilteredListToShowDate(listing);
        } else {
            model.updateFilteredListToShowAllUndone();
        }
        model.setLastListing(listing);
        EventsCenter.getInstance().post(new ChangeListingEvent(listing));
        indicateCorrectCommandExecuted();
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### /java/seedu/ggist/logic/commands/SaveCommand.java
``` java
/**
 * Saves data to a specified location
 */
public class SaveCommand extends Command{

        public static final String COMMAND_WORD = "save";
        
        public static final String MESSAGE_USAGE = COMMAND_WORD + ": Saves data to a specified valid location.\n"
                + "Parameters: filepath\n"
                + "Example: " + COMMAND_WORD
                + " C:/Users/Documents/OneDrive/data or ggist2.xml";
     
    public static final String MESSAGE_SUCCESS = "File location successfully changed to %1$s.";
    public static final String MESSAGE_FAIL = "Specified directory does not exists";
    public static final String DEFAULT_FILENAME = "/ggist.xml";
    public static final String DEFAULT_FILE_FOLDER = "data/";
    private static final String DEFAULT_FILE_EXTENSION = "xml";
    
    private String filePath;
    
    /**
     * Appends default filename if path is directory
     * Prepends defaults directory if path is not a directory but has valid file extension 
     * @param String filepath
     * @throws IllegalValueException if filename is not xml or directory does not exists
     */
    public SaveCommand(String filePath) throws IllegalValueException {
        assert filePath != null;
        String extension = filePath.substring(filePath.lastIndexOf(".") + 1, filePath.length());
        if (new File(filePath).isDirectory()) {
            this.filePath = filePath + DEFAULT_FILENAME;
        } else if (!Files.exists(Paths.get(filePath)) && DEFAULT_FILE_EXTENSION.equals(extension)) {
            this.filePath = DEFAULT_FILE_FOLDER + filePath;
        } else {
            throw new IllegalValueException(MESSAGE_FAIL);
        }
   
    }
    
    /**
     * Creates a new file or overwrites existing file with same name
     * Updates the user config file to the new save file name or location
     * Post an event to indicate save file has been changed
     * 
     */
    @Override
    public CommandResult execute() {
        assert model != null;
        
       ReadOnlyTaskManager taskManager = model.getTaskManager();
        
        File file = new File(filePath);

        try {
            FileUtil.createIfMissing(file);
            XmlFileStorage.saveDataToFile(file, new XmlSerializableTaskManager(taskManager));
        } catch (Exception e) {
            return new CommandResult(e.getMessage());
        }
        
        Config updateConfig;
        try {
            Optional<Config> configOptional = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE);
            updateConfig = configOptional.get();
            updateConfig.setTaskManagerFilePath(filePath);
            ConfigUtil.saveConfig(updateConfig, Config.DEFAULT_CONFIG_FILE);
        } catch (Exception e) {
            updateConfig = new Config();
        }
        EventsCenter.getInstance().post(new ChangeSaveFileEvent(filePath));
        indicateCorrectCommandExecuted();
        return new CommandResult(String.format(MESSAGE_SUCCESS , filePath));
    }
    
    @Override
    public  String toString(){
        return COMMAND_WORD;
    }
    
}


```
###### /java/seedu/ggist/logic/commands/SearchCommand.java
``` java
/**
 * Finds and lists all tasks in GGist whose task name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class SearchCommand extends Command {

    public static final String COMMAND_WORD = "search";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose names contain any of "
            + "the specified keywords \n (not case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " milk ";

    private final Set<String> keywords;

    public SearchCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords);
        indicateCorrectCommandExecuted();
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### /java/seedu/ggist/logic/parser/DateTimeParser.java
``` java
public class DateTimeParser {

    private Date dateTime;
    private String date;
    private String time;
    
    /**
     * Parse the data and time input to a Date object
     * @param String
     * @throws IllegalValueException 
     */
    public DateTimeParser(String raw) throws IllegalValueException {
        assert raw != null;
        List<Date> dateTimeData = new PrettyTimeParser().parse(raw);
        if (dateTimeData.size() == 0) {
            throw new IllegalValueException(Messages.MESSAGE_INVALID_DATE_TIME_VALUE);
        }
        dateTime = dateTimeData.get(0);
    }
    
    /**
     * Extracts time from Date object and convert to formatted String
     * @param Date
     * @throws IllegalValueException
     */
    private void parseTime(Date dateTime) throws IllegalValueException {
        SimpleDateFormat sdf = new SimpleDateFormat("h:mm a");
        time = sdf.format(dateTime).toString();
        String currentTime = sdf.format(new Date()).toString();
        if (currentTime.equals(time)) {
            time = "";
        }
    }
    /**
     * Extracts date from Date object and convert to formatted String
     * @param Date
     * @throws IllegalValueException
     */
    private void parseDate(Date dateTime) {
        SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yy");
        date = sdf.format(dateTime).toString();
    }
    
    /* Return date in String format of the Date object*/
    public String getDate() {
        parseDate(dateTime);
        return date;
    }
    /* Return time in String format of the Date object*/
    public String getTime() throws IllegalValueException {
        parseTime(dateTime);
        return time;
    }
    /* Return Date object*/
    public Date getDateTime() {
        return dateTime;
    }
}
```
###### /java/seedu/ggist/logic/parser/Parser.java
``` java
/**
 * Parses user input.
 */
public class Parser {

    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)",
            Pattern.CASE_INSENSITIVE);

    private static final Pattern TASK_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)",
            Pattern.CASE_INSENSITIVE);

    private static final Pattern KEYWORDS_ARGS_FORMAT = Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)",
            Pattern.CASE_INSENSITIVE); // one or more keywords separated by
                                       // whitespace

    private static final Pattern LIST_ARGS_FORMAT = Pattern.compile("(?<listing>.*)", Pattern.CASE_INSENSITIVE);

    // regex for floating
    private static final Pattern FLOATING_TASK_DATA_ARGS_FORMAT = Pattern.compile("(?<taskName>.+)",
            Pattern.CASE_INSENSITIVE);

    // regex for floating with priority
    private static final Pattern FLOATING_WITH_PRIORITY = Pattern
            .compile("(?<taskName>.+)" + "\\s*(?:-)(?<priority>.+)", Pattern.CASE_INSENSITIVE);

    // regex for tasks with deadline
    private static final Pattern DEADLINE_TASK_DATA_ARGS_FORMAT = Pattern
            .compile("(?<taskName>.+)" + "((\\s*,\\s*)|(\\s+?(by|on)\\s+?))(?<dateTime>.+)", Pattern.CASE_INSENSITIVE);

    // regex for tasks with start and end time spanning diff days
    private static final Pattern EVENT_TASK_DIFF_DAYS_DATA_ARGS_FORMAT = Pattern
            .compile("(?<taskName>.+)" + "((\\s*,\\s*)|(\\s+?(from)\\s+?))(?<startDateTime>.+)"
                    + "((\\s*(,)\\s*)|(\\s+?to\\s+?))(?<endDateTime>.+)", Pattern.CASE_INSENSITIVE);

    // regex for tasks with start and end time on same days
    private static final Pattern EVENT_TASK_SAME_DAY_DATA_ARGS_FORMAT = Pattern.compile("(?<taskName>.+)"
            + "((\\s*,\\s*)|(\\s+?(by|on)\\s+))(?<day>.+" + ")((\\s*,\\s*)|(\\s+?(from)\\s+))(?<startTime>.+)"
            + "((\\s*(,)\\s*)|(\\s+?to\\s+?))(?<endTime>.+)", Pattern.CASE_INSENSITIVE);

    // regex for edit argument
    private static final Pattern EDIT_DATA_ARGS_FORMAT = Pattern.compile(
            "(?<field>(task|start date|start time|end date|end time|priority))" + "\\s+?(?<value>.+)",
            Pattern.CASE_INSENSITIVE);
    // regex for edit format
    private static final Pattern VALID_EDIT_FORMAT = Pattern.compile("(?<index>\\d+?)(?<fields>.*)",
            Pattern.CASE_INSENSITIVE);

    public static final Pattern PRIORITY_MATCHER_REGEX = Pattern.compile("(?:.*-\\s*(?<priority>.+))");

```
###### /java/seedu/ggist/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        assert args != null;
        final String taskType = matchTaskType(args.trim());
        if (taskType.equals("taskTypeNotFound")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        try {
            if (taskType.equals("eventTask")) {
                return addEventTask(args);
            } else if (taskType.equals("deadlineTask")) {
                return addDeadlineTask(args);
            } else if (taskType.equals("floatingTask")) {
                return addFloatingTask(args);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
        return null;
    }

    /**
     * Parses arguments in the context of adding an event task command.
     *
     * @param args
     *            full command args string
     * @throws IllegalValueException
     * @return the prepared Add command
     */
    private AddCommand addEventTask(String args) throws IllegalValueException {
        assert args != null;
        Matcher matcher = EVENT_TASK_DIFF_DAYS_DATA_ARGS_FORMAT.matcher(args.trim());
        Matcher matcherSameDay = EVENT_TASK_SAME_DAY_DATA_ARGS_FORMAT.matcher(args.trim());
        if (matcherSameDay.matches()) {
            return new AddCommand(matcherSameDay.group("taskName"),
                    new DateTimeParser(matcherSameDay.group("day")).getDate(),
                    new DateTimeParser(matcherSameDay.group("startTime")).getTime(),
                    new DateTimeParser(matcherSameDay.group("day")).getDate(),
                    new DateTimeParser(matcherSameDay.group("endTime")).getTime(),
                    parsePriority(matcherSameDay.group("endTime")));

        } else if (matcher.matches()) {
            return new AddCommand(matcher.group("taskName"),
                    new DateTimeParser(matcher.group("startDateTime")).getDate(),
                    new DateTimeParser(matcher.group("startDateTime")).getTime(),
                    new DateTimeParser(matcher.group("endDateTime")).getDate(),
                    new DateTimeParser(matcher.group("endDateTime")).getTime(),
                    parsePriority(matcher.group("endDateTime")));
        }
        return null;
    }

    /**
     * Parses arguments in the context of adding an deadline task command.
     *
     * @param args
     *            full command args string
     * @throws IllegalValueException
     * @return the prepared Add command
     */
    private AddCommand addDeadlineTask(String args) throws IllegalValueException {
        assert args != null;
        Matcher matcher = EVENT_TASK_DIFF_DAYS_DATA_ARGS_FORMAT.matcher(args.trim());
        matcher = DEADLINE_TASK_DATA_ARGS_FORMAT.matcher(args.trim());
        if (matcher.matches()) {
            return new AddCommand(matcher.group("taskName"), 
                   new DateTimeParser(matcher.group("dateTime")).getDate(),
                   new DateTimeParser(matcher.group("dateTime")).getTime(), 
                   parsePriority(matcher.group("dateTime")));
        }
        return null;
    }

    /**
     * Parses arguments in the context of adding an floating task command.
     *
     * @param args
     *            full command args string
     * @throws IllegalValueException
     * @return the prepared Add command
     */
    private AddCommand addFloatingTask(String args) throws IllegalValueException {
        assert args != null;
        Matcher matcher = FLOATING_TASK_DATA_ARGS_FORMAT.matcher(args.trim());
        Matcher matcherFloating = FLOATING_WITH_PRIORITY.matcher(args.trim());
        if (matcherFloating.matches()) {
            return new AddCommand(matcherFloating.group("taskName"), matcherFloating.group("priority"));
        } else if (matcher.matches()) {
            return new AddCommand(matcher.group("taskName"), null);
        }
        return null;
    }

    /**
     * Matches arg string format and validates
     * 
     * @param args
     *            full command string
     * @return the task type in String
     */
    private String matchTaskType(String args) {
        Matcher matcher;
        if ((matcher = EVENT_TASK_DIFF_DAYS_DATA_ARGS_FORMAT.matcher(args)).matches()
             || ((matcher = EVENT_TASK_SAME_DAY_DATA_ARGS_FORMAT.matcher(args)).matches())) {
            return new String("eventTask");
        } else if ((matcher = DEADLINE_TASK_DATA_ARGS_FORMAT.matcher(args)).matches()) {
            return new String("deadlineTask");
        } else if ((matcher = FLOATING_TASK_DATA_ARGS_FORMAT.matcher(args)).matches()
                    || ((matcher = FLOATING_WITH_PRIORITY.matcher(args)).matches())) {
            return new String("floatingTask");
        }
        return new String("taskTypeNotFound");
    }

    private String parsePriority(String args) {
        Matcher matcherPriority = PRIORITY_MATCHER_REGEX.matcher(args);
        if (!matcherPriority.matches()) {
            return null;
        }
        return matcherPriority.group("priority");
    }

```
###### /java/seedu/ggist/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the find person command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareSearch(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SearchCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new SearchCommand(keywordSet);
    }


    /**
     * Parses arguments in the context of the list command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareList(String args) {
        final Matcher matcher = LIST_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        }
        final String listing = matcher.group("listing");

        try {
            if (args.equals("") || ListCommand.isValidListArgs(listing)) {
                return new ListCommand(listing);
            } else {
                String dateListing = new DateTimeParser(listing).getDate();
                return new ListCommand(dateListing);
            }
        } catch (IllegalValueException e) {
            return new IncorrectCommand(ListCommand.MESSAGE_USAGE);
        }
    }

    /**
     * Parses arguments in the context of the save command.
     *
     * @param args
     *            full command arguments string
     * @return the prepared command
     */
    private Command prepareSave(String args) {
        if (args.equals("")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SaveCommand.MESSAGE_USAGE));
        }
        try {
            return new SaveCommand(args.trim());
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage() + "\n" + SaveCommand.MESSAGE_USAGE);
        }
    }
```
###### /java/seedu/ggist/model/ModelManager.java
``` java
    /**
     * Constructor for Model Manager
     * Sets current date
     * Raise an event for listing changed to current date
     * @param initialData
     * @param userPrefs
     */
    @SuppressWarnings("unchecked")
    public ModelManager(ReadOnlyTaskManager initialData, UserPrefs userPrefs) {
        taskManager = new TaskManager(initialData);
        filteredTasks = new FilteredList<>(taskManager.getTasks());
        sortedTasks = new SortedList<>(filteredTasks, Task.getTaskComparator());
        setTodayDate();
        updateListing();
        raise(new ChangeListingEvent(lastListing));
    }

    @Override
    public String getLastListing() {
        return lastListing;
    }

    @Override
    public void setLastListing(String listing) {
        lastListing = listing;
    }

```
###### /java/seedu/ggist/model/ModelManager.java
``` java
    /** Creates a Date object with today's date */
    private void setTodayDate() {
        today = LocalDate.now().format(DateTimeFormatter.ofPattern("EEE, dd MMM YY"));
        lastListing = today;
    }

    /** Raises an event to indicate the model has changed */
    private void indicateTaskManagerChanged() {
        raise(new TaskManagerChangedEvent(taskManager));
    }

    /** Raises an event to indicate the new task added */
    private void indicateTaskChanges(Task task) {
        indicateTaskManagerChanged();
        raise(new JumpToListRequestEvent(getFilteredTaskList().indexOf(task)));
    }

```
###### /java/seedu/ggist/model/ModelManager.java
``` java
    /**
     * Updates filtered list to show based on last shown listing choice
     */
    public void updateListing() {
        if (lastListing == null) {
            updateFilteredListToShowDate(today);
        } else if (lastListing.equals("")) {
            updateFilteredListToShowAllUndone();
        } else if (lastListing.equals("done")) {
            updateFilteredListToShowAllDone();
        } else if (lastListing.equals("high") || lastListing.equals("med") || lastListing.equals("low")) {
            updateFilteredListToPriority(lastListing);
        } else if (lastListing.equals("all")) {
            updateFilteredListToShowAll();
        }  else if (TaskDate.isValidDateFormat(lastListing)) {
            updateFilteredListToShowDate(lastListing);
        }
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return getSortedTaskList();
    }

    /**
     * Sorts filtered list based on start date and time
     */
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getSortedTaskList() {
        sortedTasks = new SortedList<>(filteredTasks, Task.getTaskComparator());
        return new UnmodifiableObservableList<>(sortedTasks);
    }

```
###### /java/seedu/ggist/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowDate(String keywords) {
        updateFilteredTaskList(new PredicateExpression(new DateQualifier(keywords)));
    }

    private void updateFilteredListToShowDate(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    @Override
    public void updateFilteredListToPriority(String keyword) {
        updateFilteredTaskList(new PredicateExpression(new PriorityQualifier(keyword)));
    }

    private void updateFilteredListToPriority(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
    }

    public void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    @Override
    public void updateFilteredListToShowChanges() {
        System.out.println(filteredTasks.getPredicate());
    }

    // ========== Inner classes/interfaces used for filtering
    // ==================================================

```
###### /java/seedu/ggist/model/ModelManager.java
``` java
    private class DateQualifier implements Qualifier {
        private String taskDateKeyWords;

        DateQualifier(String taskDateKeyWords) {
            this.taskDateKeyWords = taskDateKeyWords;
        }
        
        /**
         * Returns true for tasks matching date and is not done
         * Returns true for floating tasks
         * Returns true for overdue tasks
         */
        @Override
        public boolean run(ReadOnlyTask task) {
            if (taskDateKeyWords == null) {
                return true;
            }
            return ((taskDateKeyWords.equalsIgnoreCase(task.getStartDate().toString())
                    || taskDateKeyWords.equalsIgnoreCase(task.getEndDate().toString()))
                    && !task.isDone())
                    || ((task.getStartDate().value.equals(Messages.MESSAGE_NO_START_DATE_SPECIFIED)
                    && (task.getStartTime().value.equals(Messages.MESSAGE_NO_START_TIME_SET)
                    && (task.getEndDate().value.equals(Messages.MESSAGE_NO_END_DATE_SPECIFIED)
                    && (task.getEndTime().value.equals(Messages.MESSAGE_NO_END_TIME_SET))
                    && !task.isDone()))
                    || (task.isOverdue() && !task.isDone())));
        }
        
        @Override
        public String toString() {
            return "name=" + String.join(", ", taskDateKeyWords);
        }
    }

    private class PriorityQualifier implements Qualifier {
        private String priority;

        PriorityQualifier(String priority) {
                this.priority = priority;
        }
        
        /**
         * Returns true for tasks matching priority and is not done
         */
        @Override
        public boolean run(ReadOnlyTask task) {
            if (priority == null) {
                    return true;
            }
            return (priority.equals(task.getPriority().value) && !task.isDone());
        }

```
###### /java/seedu/ggist/model/task/DeadlineTask.java
``` java
/**
 * Represents a DeadlineTask in the task manager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class DeadlineTask extends Task implements ReadOnlyTask {
    /**
     * Every field must be present and not null.
     * @throws IllegalValueException 
     */
    public DeadlineTask(TaskName taskName, TaskDate endDate, TaskTime endTime, Priority priority) throws IllegalValueException {
        super(taskName, 
              new TaskDate(Messages.MESSAGE_NO_START_DATE_SPECIFIED),
              new TaskTime(Messages.MESSAGE_NO_START_TIME_SET),
              endDate, endTime, priority);
    }
    
    /**
     * Copy constructor.
     * @throws IllegalValueException 
     */
    public DeadlineTask(ReadOnlyTask source) throws IllegalValueException {
        super(source.getTaskName(), source.getStartDate(), source.getStartTime(), source.getEndDate(), source.getEndTime(), source.getPriority());
    }
    
    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(taskName, startDate, startTime, endDate, endTime, priority);
    }
}
```
###### /java/seedu/ggist/model/task/EventTask.java
``` java
/**
 * Represents a EventTask in the task manager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class EventTask extends Task implements ReadOnlyTask {

    /**
     * Every field must be present and not null.
     * @throws IllegalValueException 
     */
    public EventTask(TaskName taskName, TaskDate startDate, TaskTime startTime, TaskDate endDate, TaskTime endTime, Priority priority) throws IllegalValueException {
        super(taskName, startDate, startTime, endDate, endTime, priority);
    }
    
    public EventTask(TaskName taskName, TaskDate startDate, TaskTime startTime, TaskDate endDate, TaskTime endTime, Priority priority, 
                    boolean isDone, boolean isOverdue) throws IllegalValueException {
        super(taskName, startDate, startTime, endDate, endTime, priority);
        this.isDone = isDone;
        this.isOverdue = isOverdue;
    }
   
    /**
     * Copy constructor.
     * @throws IllegalValueException 
     */
    public EventTask(ReadOnlyTask source) throws IllegalValueException {
        this(source.getTaskName(), source.getStartDate(), source.getStartTime(), source.getEndDate(), source.getEndTime(), source.getPriority(), source.isDone(), source.isOverdue());
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(taskName, startDate, startTime, endDate, endTime, priority);
    }
}
```
###### /java/seedu/ggist/model/task/FloatingTask.java
``` java
/**
 * Represents a FloatingTask in the task manager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class FloatingTask extends Task implements ReadOnlyTask {

    /**
     * Every field must be present and not null.
     * @throws IllegalValueException 
     */
    public FloatingTask(TaskName taskName, Priority priority) throws IllegalValueException {
        super(taskName, 
              new TaskDate(Messages.MESSAGE_NO_START_DATE_SPECIFIED),
              new TaskTime(Messages.MESSAGE_NO_START_TIME_SET),
              new TaskDate(Messages.MESSAGE_NO_END_DATE_SPECIFIED),
              new TaskTime(Messages.MESSAGE_NO_END_TIME_SET), 
              priority);
    }

    /**
     * Copy constructor.
     * @throws IllegalValueException 
     */
    public FloatingTask(ReadOnlyTask source) throws IllegalValueException {
        super(source.getTaskName(), source.getStartDate(), source.getStartTime(), source.getEndDate(), source.getEndTime(), source.getPriority());
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(taskName, startDate, startTime, endDate, endTime, priority);
    }

}
```
###### /java/seedu/ggist/model/task/Priority.java
``` java
/**
 * Represents a Task's priority in the GGist.
 * Guarantees: immutable; is valid as declared in {low|med|high}
 */
public class Priority {

    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "Task priority must be prefixed with -\n "
            + "Valid priority level are -low , -med , -high";
    
    public static final String MESSAGE_EDIT_PRIORITY_CONSTRAINTS = "Editing a task priority must be in the following format:/n" 
            + "edit [INDEX] priority [LEVEL], where LEVEL = low, med, or high";

    public static final String PRIORITY_VALIDATION_REGEX = "low|med|high|"+ Messages.MESSAGE_NO_PRIORITY_VALUE;

    public String value;
    
    public static enum PriorityType {
        LOW("low"), MEDIUM("med"), HIGH("high"); 
        
        public final String priorityType;
        PriorityType(String priorityType) {
            this.priorityType = priorityType;
        }
        
        @Override
        public String toString() {
            return this.priorityType;
        }
    }

    /**
     * Validates given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        if (priority == null) {
            value =  Messages.MESSAGE_NO_PRIORITY_VALUE;
        } else if (!isValidPriority(priority.trim())){
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        } else {
            priority = priority.trim();
            value = priority;
        }
    }
    
    /**
     * Changes the value attribute
     * @param String
     * @throws IllegalValueException
     */
    public void editPriority(String newPriority) throws IllegalValueException {
        assert newPriority!= null;
        newPriority = newPriority.trim();
        if (!isValidPriority(newPriority)) {
            throw new IllegalValueException(MESSAGE_EDIT_PRIORITY_CONSTRAINTS);
        }
        this.value = newPriority;
    }
    
    /**
     * Returns the matched string
     */
    public static boolean isValidPriority(String test) {
        return test.matches(PRIORITY_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Priority // instance of handles nulls
                && this.value.equals(((Priority) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/seedu/ggist/model/task/Task.java
``` java
/**
 * Represents a Task in the task manager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Task implements ReadOnlyTask{

    protected TaskName taskName;
    protected TaskDate startDate;
    protected TaskTime startTime;
    protected TaskDate endDate;
    protected TaskTime endTime;
    protected Priority priority;
    protected boolean isDone;
    protected boolean isOverdue;
    protected Date start;
    protected Date end;
    
    public static enum TaskType {
        FLOATING("task"), DEADLINE("deadline"), EVENT("event"); 
        
        private final String taskType;
        TaskType(String taskType) {
            this.taskType = taskType;
        }
        
        @Override
        public String toString() {
            return this.taskType;
        }
    }

    /**
     * Every field must be present and not null.
     * @throws IllegalValueException 
     * 
    */      
    public Task(TaskName taskName, TaskDate startDate, TaskTime startTime, TaskDate endDate, TaskTime endTime, Priority priority) throws IllegalValueException {
        
        this.taskName = taskName;
        this.startDate = startDate;
        this.startTime = startTime;
        this.endDate = endDate;
        this.endTime = endTime;
        this.priority = priority;
        if (startDate.value.equals(Messages.MESSAGE_NO_START_DATE_SPECIFIED) && startTime.value.equals(Messages.MESSAGE_NO_START_TIME_SET)) {
            constructStartDateTime(endDate, endTime);
        } else {
            constructStartDateTime(startDate, startTime);
        }
        constructEndDateTime(endDate, endTime);
        checkTimeClash();
    }
    

    /**
     * Copy constructor.
     * @throws IllegalValueException 
     */
    public Task(ReadOnlyTask source) throws IllegalValueException {
        this(source.getTaskName(), source.getStartDate(), source.getStartTime(), source.getEndDate(), source.getEndTime(), source.getPriority());
    }
          
    /**
     * Creates a Date object from the start date and start time
     * @throws IllegalValueException
     */
    public void constructStartDateTime(TaskDate date, TaskTime time) throws IllegalValueException {
        start = formatMissingDateTime(date, time);
    }
    
    /**
     * Creates a Date object from the end date and end time
     * @throws IllegalValueException
     */
    public void constructEndDateTime(TaskDate date, TaskTime time) throws IllegalValueException {
        end = formatMissingDateTime(date, time);
    }
    
    /**
     * Sets missing date and time to a large value
     * @param TaskDate
     * @param TaskTime
     * @return Date
     * @throws IllegalValueException 
     */
    private Date formatMissingDateTime(TaskDate date, TaskTime time) throws IllegalValueException {
        if ((date.value.equals(Messages.MESSAGE_NO_START_DATE_SPECIFIED) || date.value.equals(Messages.MESSAGE_NO_END_DATE_SPECIFIED)) 
             &&(time.value.equals(Messages.MESSAGE_NO_START_TIME_SET) || time.value.equals(Messages.MESSAGE_NO_END_TIME_SET))) {
            return new DateTimeParser("1st January 2050 11:59pm").getDateTime();
        } else if ((date.value.equals(Messages.MESSAGE_NO_START_DATE_SPECIFIED) || date.value.equals(Messages.MESSAGE_NO_END_DATE_SPECIFIED))){
            return new DateTimeParser("1st January 2050 " + time.value).getDateTime();
        } else if ((time.value.equals(Messages.MESSAGE_NO_START_TIME_SET) || time.value.equals(Messages.MESSAGE_NO_END_TIME_SET))) {
            return new DateTimeParser("11:59 pm " + date.value).getDateTime();
        } else {
            return new DateTimeParser(time.value + " " + date.value).getDateTime();
        }        
    }  
    /**
     * check if end time is before the current time. set task overdue if true
     * checks if the end is before the start
     * @throws IllegalValueException
     */
    public void checkTimeClash() throws IllegalValueException {
        Date currentDate  = new Date();
        if (end.before(currentDate) && isDone == false) {
            isOverdue = true;
        } else if (!end.before(currentDate)) {
            setNotOverdue();
        }
        if(end.before(start)) {
            throw new IllegalValueException("End cannot be earlier than start!");
        }
    }
    
    /**
     * compares task based on start date and time
     * @return dateTimeComparator
     */
    public static Comparator getTaskComparator(){
        return new Comparator<Task>(){
            public int compare (Task t1, Task t2){
                    
                if (t1.getStartDateTime().equals(t2.getStartDateTime())
                    && (t1.getEndDateTime().equals(t2.getEndDateTime()))) {
                    return t1.getTaskName().taskName.compareTo(t2.getTaskName().taskName);
                } 
                
                if (t1.getStartDateTime().before(t2.getStartDateTime())) {
                    return -1;
                } else if (t1.getStartDateTime().after(t2.getStartDateTime())) {
                    return 1;
                } 
                
                if (t1.getEndDateTime().before(t2.getEndDateTime())) {
                    return -1;
                } else if (t1.getEndDateTime().after(t2.getEndDateTime())) {
                    return 1;
                }
                
                return 0;
            }
        };
    }
    
    /**
     * Set task as done
     * Mark task as not overdue
     */
    public void setDone() {
        isDone = true;
        setNotOverdue();
    }
    
    public void setUndone() {
        isDone = false;
        if (end.before(new Date())) {
            isOverdue = true;
        }
    }
    
    /**
     * Mark task as not overdue
     */
    public void setNotOverdue() {
        isOverdue = false;
    }

    
    @Override
    public boolean isDone() {
        return isDone;
    }
```
###### /java/seedu/ggist/model/task/TaskDate.java
``` java
/**
 * Represents a Task's taskDate in the GGist.
 * Guarantees: immutable; is valid as declared in right format
 */
public class TaskDate {

    public static final String MESSAGE_DATE_CONSTRAINTS =
            "Date is unreadable and should contains only spaces, letters or digits. \n" 
            + "Example: 22 Nov or Decemeber 22 or tomorrow";
    public static final String DATE_VALIDATION_REGEX = ".+";

    public String value;
    public String testValue;

    /**
     * Validates given taskDate.
     *
     * @throws IllegalValueException if given taskDate string is invalid.
     */
    public TaskDate(String date) throws IllegalValueException {
        assert date != null;
        date = date.trim();
        if(date.equals(Messages.MESSAGE_NO_START_DATE_SPECIFIED) || date.equals(Messages.MESSAGE_NO_END_DATE_SPECIFIED)) {
            this.value = date;
            this.testValue = date;
        } else if (!isValidDateFormat(date)) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        this.value = date;
    }
```
###### /java/seedu/ggist/model/task/TaskDate.java
``` java
    /**
     * Returns if a given string is a valid taskDate.
     */
    public static boolean isValidDateFormat(String test) {
        return test.matches(DATE_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }
    public String getTestValue() {
    	return testValue;
    }
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instance of handles nulls
                && this.value.equals(((TaskDate) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
}
```
###### /java/seedu/ggist/model/task/TaskName.java
``` java
/**
 * Represents a Task's name in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class TaskName {
```
###### /java/seedu/ggist/model/task/TaskName.java
``` java
    public String taskName;

    /**
     * Validates given task name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public TaskName(String taskName) throws IllegalValueException {
        assert taskName != null;
        taskName = taskName.trim();
        this.taskName = taskName;
    }
```
###### /java/seedu/ggist/model/task/TaskTime.java
``` java
/**
 * Represents a Task's time in GGist 
 * Guarantees: immutable; is valid as declared in {@TaskTime #isValidTime(String)}
 */
public class TaskTime {
    

    public static final String MESSAGE_TIME_CONSTRAINTS =
            "Only accepts time in 24hr format [hhmm] or 12hr format [hh.mm am/pm]\n"
            + "Example: 2359 or 11.59pm\n";
    public static final String TIME_VALIDATION_REGEX = ".+";
    public String value;

    /**
     * Validates given time.
     *
     * @throws IllegalValueException if given time string is invalid.
     */
    public TaskTime(String time) throws IllegalValueException {
        assert time != null;
        time = time.trim();
        if (!time.equals(Messages.MESSAGE_NO_START_TIME_SET) && !time.equals(Messages.MESSAGE_NO_END_TIME_SET)
             && !isValidTime(time)) {
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }
        this.value = time;
    }
```
###### /java/seedu/ggist/storage/XmlAdaptedTask.java
``` java
    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        taskName = source.getTaskName().taskName;
        startDate = source.getStartDate().value;
        startTime = source.getStartTime().value;
        endDate = source.getEndDate().value;
        endTime = source.getEndTime().value;
        done = source.isDone();
        priority = source.getPriority().value;
        overdue = source.isOverdue();
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     */
    public Task toModelType() throws IllegalValueException {
        
        final TaskName taskName = new TaskName(this.taskName);
        final TaskDate startDate = new TaskDate(this.startDate);
        final TaskTime startTime = new TaskTime(this.startTime);
        final TaskDate endDate = new TaskDate(this.endDate);
        final TaskTime endTime = new TaskTime(this.endTime);
        final boolean done = this.done;
        final boolean overdue = this.overdue;
        final Priority priority = new Priority(this.priority);
        Task newTask = new Task(taskName, startDate, startTime, endDate, endTime, priority);
        if (done) {
            newTask.setDone(); 
        }

        return newTask;
    }
}
```
###### /java/seedu/ggist/ui/ListingHeader.java
``` java
    public void configure(String listing) {
        addMainPane();
        addListing();
        setListing(listing);
        registerAsAnEventHandler(this);
    }
    
    private void addMainPane() {
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }
    
    public void setListing(String listing) {
        if (listing.equals("all")) {
            this.listing.setText("ALL TASKS");
        } else if (listing.equals("done")) {
            this.listing.setText("ALL COMPLETED TASKS");
        } else if (listing.equals("high") || listing.equals("med") || listing.equals("low")) {
            this.listing.setText(listing.toUpperCase() + " PRIORITY TASKS");
        } else if (listing.equals("")) {
            this.listing.setText("TASKS NOT COMPLETED");
        } else {
            SimpleDateFormat sdf = new SimpleDateFormat("EEEE, dd MMMMM yyyy");
            this.listing.setText(sdf.format(new PrettyTimeParser().parse(listing).get(0)).toString());
        }
       
    }
   
    private void addListing() {
        FxViewUtil.applyAnchorBoundaryParameters(listHeader, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(this.listing);
    }


    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }
```
###### /java/seedu/ggist/ui/StatusBarFooter.java
``` java
    @Subscribe
    public void handleChangeFileLocationEvent(ChangeFileLocationEvent event) {
        String newLocation = event.path;
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Settinng file location to " + newLocation));
        setSaveLocation(newLocation);
    }
    
}
```
###### /java/seedu/ggist/ui/TaskCard.java
``` java
    @FXML
    public void initialize() {
        taskName.setText(task.getTaskName().taskName);
        id.setText(displayedIndex + ". ");
        if (task.getStartDate().value.equals(Messages.MESSAGE_NO_START_DATE_SPECIFIED)) {
            startDate.setText("");
        } else {
            startDate.setText(task.getStartDate().value);
        }
        if (task.getStartTime().value.equals(Messages.MESSAGE_NO_START_TIME_SET)) {
            startTime.setText("");
        } else {
            startTime.setText(task.getStartTime().value);
        }
        if (task.getEndDate().value.equals(Messages.MESSAGE_NO_END_DATE_SPECIFIED)) {
            endDate.setText("");
        } else {
            endDate.setText(task.getEndDate().value);
        } 
        if (task.getEndTime().value.equals(Messages.MESSAGE_NO_END_TIME_SET)) {
            endTime.setText("");
        } else {
            endTime.setText(task.getEndTime().value);
        }
        if (task.getPriority().value.equals(Messages.MESSAGE_NO_PRIORITY_VALUE)) {
            id.textFillProperty().bind(none.valueProperty());
            taskName.textFillProperty().bind(none.valueProperty());
        } else {
            String level = task.getPriority().value;
            if (level.equals("low")) {
                id.textFillProperty().bind(low.valueProperty());
                taskName.textFillProperty().bind(low.valueProperty());
            } else if (level.equals("med")) {
                id.textFillProperty().bind(med.valueProperty());
                taskName.textFillProperty().bind(med.valueProperty());
            } else if (level.equals("high")) {
                id.textFillProperty().bind(high.valueProperty());
                taskName.textFillProperty().bind(high.valueProperty());
            }
        }
        if (task.isDone()) {
            id.textFillProperty().bind(done.valueProperty());
            taskName.textFillProperty().bind(done.valueProperty());
        }
        if (task.isOverdue()) {
            startTime.textFillProperty().bind(overdue.valueProperty());
            endTime.textFillProperty().bind(overdue.valueProperty());
            startDate.textFillProperty().bind(overdue.valueProperty());
            endDate.textFillProperty().bind(overdue.valueProperty());
        } else {
            startTime.textFillProperty().bind(none.valueProperty());
            endTime.textFillProperty().bind(none.valueProperty());
            startDate.textFillProperty().bind(none.valueProperty());
            endDate.textFillProperty().bind(none.valueProperty());
        }
    }
```
###### /java/seedu/ggist/ui/TaskCard.java
``` java
    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        
    }
}
```
###### /resources/view/DarkTheme.css
``` css
.list-view .list-cell:selected:focused {
    -fx-background-color: derive(#A366B0, 40%);
}
```
###### /resources/view/Extensions.css
``` css
.correct:focused {
    -fx-focus-color: #00cc99;
    -fx-faint-focus-color: #d3524422;

    -fx-highlight-fill: -fx-accent;
    -fx-highlight-text-fill: white;
    -fx-background-color:
        -fx-focus-color,
        -fx-control-inner-background,
        -fx-faint-focus-color,
        linear-gradient(from 0px 0px to 10px 10px, derive(-fx-control-inner-background, -9%), -fx-control-inner-background);
    -fx-background-insets: -0.2, 1, -1.4, 3;
    -fx-background-radius: 3, 2, 4, 0;
    -fx-prompt-text-fill: transparent;
}

.correct:focused:hover {
    -fx-focus-color: #00cc99;
    -fx-faint-focus-color: #d3524422;

    -fx-highlight-fill: -fx-accent;
    -fx-highlight-text-fill: white;
    -fx-background-color:
        -fx-focus-color,
        -fx-control-inner-background,
        -fx-faint-focus-color,
        linear-gradient(from 0px 0px to 10px 10px, derive(-fx-control-inner-background, -9%), -fx-control-inner-background);
    -fx-background-insets: -0.2, 1, -1.4, 3;
    -fx-background-radius: 3, 2, 4, 0;
    -fx-prompt-text-fill: transparent;
}
```
